# 题目 - 望远镜中的最高海拔

## 题目描述

科技馆内有一台虚拟观景望远镜，它可以用来观测特定纬度地区的地形情况。该纬度的海拔数据记于数组 `heights` ，其中 `heights[i]` 表示对应位置的海拔高度。请找出并返回望远镜视野范围 `limit` 内，可以观测到的最高海拔值。

示例 1：

* 输入：heights = [14,2,27,-5,28,13,39], limit = 3
* 输出：[27,27,28,28,39]
* 解释：
* `滑动窗口的位置`                `最大值`
* `---------------------`       `-----`
* `[14 2 27] -5 28 13 39`         `27`
* `14 [2 27 -5] 28 13 39`         `27`
* `14 2 [27 -5 28] 13 39`         `28`
* `14 2 27 [-5 28 13] 39`         `28`
* `14 2 27 -5 [28 13 39]`         `39`


提示：

你可以假设输入总是有效的，在输入数组不为空的情况下：

* `1` <= `limit` <= `heights.length`
* `-10000` <= `heights[i]` <= `10000`

## 题解

构建一个单调队列（递增或递减均可），让滑动窗口右侧从数组最左侧开始滑动，即`right`初始为`0`,`left`初始为`0-limit+1`

窗口右侧每次增加一项`new`时，首先从最小一侧遍历，把所有小于新加入值`new`的队列元素删除，然后将`new`添加至最低一侧。
这一步是为了避免当有左侧元素退出时，退出的值不是最大值时该值可能留在队列中

每次循环当所有需要从队列中删除的元素都处理完之后，再进行新元素的添加

当`left`大于等于`0`,也就是进入数组后，每次循环将当前最大值记录

`单调队列/单调栈算法要点：遍历时保证每轮中队列/栈的单调性`

```java
class Solution {
    public int[] maxAltitude(int[] heights, int limit) {
        if(heights.length == 0 || limit == 0) return new int[0];
        Deque<Integer> deque = new LinkedList<>();
        int[] resList = new int[heights.length - limit + 1];
        int left=1-limit, right=0;
        //单调递增队列
        while(right<heights.length){
            //窗口左侧退出，判断是否需要删除最大值
            if(left > 0 && deque.peekLast() == heights[left-1]){
                deque.removeLast();
            }
            //窗口右侧进入，遍历删除所有小于该值
            while(!deque.isEmpty() && deque.peekFirst() < heights[right]){
                deque.removeFirst();
            }
            //添加新值至最小一侧
            deque.addFirst(heights[right]);
            //记录每个窗口的答案
            if(left >= 0) {
                resList[left] = deque.peekLast();
            }
            left++;
            right++;
        }
        return resList;
    }
}
```
