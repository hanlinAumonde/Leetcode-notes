# 题目 - 彩灯装饰记录1

## 题目描述

一棵圣诞树记作根节点为 root 的二叉树，节点值为该位置装饰彩灯的颜色编号。请按照从 左 到 右 的顺序返回每一层彩灯编号。

### `TreeNode`结构

```java
public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }
}
```

### 示例 1：

![](./图片/彩灯装饰记录3_示例1.png)

* 输入：root = `[8,17,21,18,null,null,6]`
* 输出：`[8,17,21,18,6]`


### 提示：

`节点总数` <= 1000

## 题解

按左到右的顺序返回每层节点的值，这是一个典型的层序遍历（广度优先/BFS），我们有两种思路实现：

### 使用递归的方式遍历节点

设置类变量res，用于添加已遍历的节点，递归函数使用一个`TreeNode`的列表作为入参，其包含上一次递归中对应层节点的所有子节点，按左至右的顺序排列

```java
class Solution {
    List<Integer> res = new ArrayList<>();

    public int[] decorateRecord(TreeNode root) {
        if(root == null) return new int[0];
        List<TreeNode> rootList = Arrays.asList(root);
        recurSearch(rootList);
        int[] resArray = new int[res.size()];
        for(int i=0;i<res.size();i++){
            resArray[i] = res.get(i);
        }
        return resArray; 
    }

    public void recurSearch(List<TreeNode> listNodes){
        if(listNodes.size() == 0) return;
        List<TreeNode> nextList = new ArrayList<>();
        for(int i=0;i<listNodes.size();i++){
            res.add(listNodes.get(i).val);
            if(listNodes.get(i).left != null) nextList.add(listNodes.get(i).left);
            if(listNodes.get(i).right != null) nextList.add(listNodes.get(i).right);
        }
        if(!nextList.isEmpty()){
            recurSearch(nextList);
        }
    }
}
```

### 使用循环的方式遍历

使用递归的方式时，如果树深度很高，那么方法调用栈可能会很长，可以使用循环的方式模拟BFS，思路是使用一个队列，在一个while循环中每次从队列头部取出一个节点，并将其子节点按左至右的顺序添加至队列结尾，循环直到队列为空之后结束

```java
class Solution {
    public int[] decorateRecord(TreeNode root) {
        if(root == null) return new int[0];
        Queue<TreeNode> queue = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode cur = queue.poll();
            list.add(cur.val);

            if(cur.left != null) queue.offer(cur.left);
            if(cur.right != null) queue.offer(cur.right);
        }
        int[] array = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            array[i] = list.get(i);
        }
        return array;
    }
}
```

* `注意`： 如果需要改变每一层顺序，只需要对于每个节点改变遍历顺序，具体例子可以参考题目`彩灯装饰记录3`