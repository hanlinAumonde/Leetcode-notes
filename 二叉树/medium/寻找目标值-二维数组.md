# 题目 - 寻找目标值——二维数组

## 题目描述

`m*n` 的二维数组 `plants` 记录了园林景观的植物排布情况，具有以下特性：

* 每行中，每棵植物的右侧相邻植物不矮于该植物；
* 每列中，每棵植物的下侧相邻植物不矮于该植物。


请判断 `plants`中是否存在目标高度值 `target`。



### 示例 1：

* `输入`：plants = `[[2,3,6,8],[4,5,8,9],[5,9,10,12]]`, target = `8`

* `输出`：`true`


### 示例 2：

* `输入`：plants = `[[1,3,5],[2,5,7]]`, target = `4`

* `输出`：`false`


### 提示：

* 0 <= `n` <= 1000
* 0 <= `m` <= 1000

## 题解

分析可知，对于一个节点：
* 其`左侧`的节点值都小于等于当前节点
* 其`下侧`的节点值都大于等于当前节点

于是我们可以以整个矩阵的右上角作为一颗`二叉搜索树（ABS）`的根节点，左侧节点视为左字节的，下侧节点视为右子节点

这样就可以使用ABS的搜索方式查找，基于这棵树本质上是一个矩阵形状，其遍历次数最多的情况下就是遍历矩阵的长+宽，即`O（m+n）`

```java
class Solution {
    public boolean findTargetIn2DPlants(int[][] plants, int target) {
        return findABS(plants.length - 1,0,plants,target);
    }
    
    public boolean findABS(int i, int j, int[][] plants, int target){
        if(i < 0 || j < 0 || i >= plants.length || j >= plants[0].length)
            return false;
        if(plants[i][j] == target) return true;
        else if(plants[i][j] > target){
            return findABS(i-1,j,plants,target); 
        }else{
            return findABS(i,j+1,plants,target);
        }
    }
}
```