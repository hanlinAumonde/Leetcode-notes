# 题目 - 字母迷宫

## 题目描述

字母迷宫游戏初始界面记作 `m x n` 二维字符串数组 `grid`，请判断玩家是否能在 `grid` 中找到目标单词 `target`。
注意：寻找单词时 必须 `按照字母顺序`，通过水平或垂直方向相邻的单元格内的字母构成，同时，同一个单元格内的字母 `不允许被重复使用`。

![](./图片/word2.jpg)

### 示例 1：

* 输入：grid = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], target = "ABCCED"
* 输出：true
### 示例 2：

* 输入：grid = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], target = "SEE"
* 输出：true
### 示例 3：

* 输入：grid = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], target = "ABCB"
* 输出：false


### 提示：

* m == grid.length
* n = grid[i].length
* 1 <= m, n <= 6
* 1 <= target.length <= 15
* grid 和 target 仅由大小写英文字母组成

## 题解

本问题是典型的回溯问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。

`深度优先搜索`： 

可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。

`剪枝`： 

在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。

---

此处具体来说，先通过普通循环寻找字符串起点，然后调用`dfs`函数进行搜索，当当前节点`[i,j]`不满足以下条件：
* 超出迷宫范围
* 已经遍历过该节点
* 该节点字符与对应步长的target字符串对应字符不相等

则立刻返回`false`，否则当步长成功到达`target`字符串结尾，则返回`true`


```java
class Solution {
    public boolean wordPuzzle(char[][] grid, String target) {
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == target.charAt(0))
                    if(dfs(i,j,grid,target,0)) return true;
            }
        }
        return false;
    }

    public boolean dfs(int i, int j, char[][] grid, String target,int step){
        if(i < 0 || j < 0 || i >= grid.length || j >=grid[0].length) return false;
        if(grid[i][j] == ' ') return false;
        if(step < target.length()){
            if(target.charAt(step) != grid[i][j]) return false;
            else if(step == target.length() - 1) return true;
        }
        //递归开始之前将当前节点对应字符设置为`' '`
        char temp = grid[i][j];
        grid[i][j] = ' ';
        boolean res = dfs(i+1,j,grid,target,step+1) || dfs(i-1,j,grid,target,step+1) || dfs(i,j+1,grid,target,step+1) || dfs(i,j-1,grid,target,step+1);
        //递归结束后恢复原值，用来保证在递归过程中，已经遍历的节点为空字符，防止重复访问
        //恢复原值是为了防止从当前起点开始的情况下没有结果，还需要其他起点调用dfs函数时grid已经发生改变
        grid[i][j] = temp;
        return res;
    }
}
```