# 题目 - 寻找文件副本

## 题目描述

设备中存有 n 个文件，文件 id 记于数组 documents。若文件 id 相同，则定义为该文件存在副本。请返回任一存在副本的文件 id。

### 示例 1：

* `输入`：documents = `[2, 5, 3, 0, 5, 0]`
* `输出`：`0` 或 `5`


### 提示：

* 0 ≤ `documents[i]` ≤ n-1
* 2 <= `n` <= 100000

## 题解

### 思路1 - 哈希表

利用数据结构特点，容易想到使用哈希表（Set）记录数组的各个数字，当查找到重复数字则直接返回。

* 算法流程：
  * `初始化`： 新建 `HashSet` ，记为 `hmap` ；
  * 遍历数组 `documents` 中的每个数字 `doc` ：
    1. 当 `doc` 在 `hmap` 中，说明重复，直接返回 `doc` ；
    2. 将 `doc` 添加至 `hmap` 中；
  * 返回 `−1` 。本题中一定有重复数字，因此这里返回多少都可以。


```java
class Solution {
    public int findRepeatDocument(int[] documents) {
        Set<Integer> hmap = new HashSet<>();
        for(int doc : documents) {
            if(hmap.contains(doc)) return doc;
            hmap.add(doc);
        }
        return -1;
    }
}
```

### 思路2 - 原地交换

题目说明尚未被充分使用，即 在一个长度为 `n` 的数组 `documents` 里的所有数字都在 `0 ~ n-1` 的范围内 。 此说明含义：数组元素的 `索引` 和 `值` 是 `一对多` 的关系。

因此，可遍历数组并通过交换操作，使元素的 `索引` 与 `值` 一一对应（即 `documents[i]=i` ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。

* 算法流程：
  * 遍历数组 `documents` ，设索引初始值为 `i=0` :
    1. 若 `documents[i]=i` ： 说明此数字已在对应索引位置，无需交换，因此跳过；
    2. 若 `documents[documents[i]] = documents[i]` ： 代表索引 `documents[i]`处和索引 `i` 处的元素值都为 `documents[i]` ，即找到一组重复值，返回此值 `documents[i]` ；
    3. 否则： 交换索引为 i 和 documents[i] 的元素值，将此数字交换至对应索引位置。
  * 若遍历完毕尚未返回，则返回 −1 。

![](./图片/寻找文件副本题解.png)

根据上图呵算法流程，在遍历过程中，
* 第二步的`documents[documents[i]] = documents[i]`判断`documents[i]`这个索引值对应的数组值和其自己是否相等。
  * 举例来说，第一次循环`i`为`0`时，`documents[0]`为`2`，因此需要查看`documents[2]`处的值，为`1`,这证明此时遍历到的`2`这个数字是我们第一次遇到，尚未遇到副本。然后我们就将`documents[0]`和`documents[2]`进行交换，保证第一次遇到`2`之后`documents[2] = 2`
  * 然后在我们第二次遇到`2`，也就是`documents[4]`时，检查`documents[2]`发现其值已经是`2`了，这证明此处遍历到的`2`必定是一个副本值
* 因为算法流程使得任何第一次遇到的值都会被交换至其对应索引处，所以一旦存在副本，其必然能通过`documents[documents[i]] = documents[i]`判断出来

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        int i = 0;
        while(i < nums.length) {
            if(nums[i] == i) {
                i++;
                continue;
            }
            if(nums[nums[i]] == nums[i]) return nums[i];
            int tmp = nums[i];
            nums[i] = nums[tmp];
            nums[tmp] = tmp;
        }
        return -1;
    }
}
```

### 复杂度

思路一二在时间复杂度上均为O（N）, 但是思路一需要额外创建保存映射的哈希表，所以空间复杂度为O（N），而思路二原地修改，则不需要额外空间，空间复杂度为O（1）