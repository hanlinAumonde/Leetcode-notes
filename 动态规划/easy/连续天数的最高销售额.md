# 题目 - 连续天数的最高销售额

## 题目描述

某公司每日销售额记于整数数组 `sales`，请返回所有 `连续一或多天`销售额总和的最大值。

要求实现时间复杂度为 `O(n)` 的算法。


### 示例 1：

* 输入：sales = `[-2,1,-3,4,-1,2,1,-5,4]`
* 输出：6
* 解释：`[4,-1,2,1]` 此连续四天的销售总额最高，为 `6`。

### 示例 2：

* 输入：sales = `[5,4,-1,7,8]`
* 输出：23
* 解释：`[5,4,-1,7,8]` 此连续五天的销售总额最高，为 `23`。


### 提示：

* 1 <= `arr.length` <= 10^5
* -100 <= `arr[i]` <= 100

## 题解

对于一个给定的sales数组，我们构建一个dp数组：
* `dp[i]`代表：以对应`sales[i]`为连续子数组的最后一位的所有子数组中元素和的最大值，例如：
  * `dp[1] = MAX(sales[0]+sales[1], sales[1])`
  * `dp[2] = MAX(sales[0]+sales[1]+sales[2], sales[1]+sales[2], sales[2])`

* 这样对于每个`dp[i]`，由于`sales[i]`必定会被记入，而`dp[i-1]`中`sales[i-1]`必定会被记入，所以对于`dp[i]`我们可以只关心`sales[i]`加入所产生的影响

* 以上面dp[1]和dp[2]的例子来说，我们可以将dp[2]写成:
  * `MAX((sales[0]+sales[1]+sales[2], sales[1]+sales[2]), sales[2])`
  * 进而简化成`MAX((sales[0]+sales[1], sales[1]) + sales[2], sales[2])`
  * 最终变为`MAX(dp[1] + sales[2], sales[2])`
---
上述`dp[1]`和`dp[2]`的结论可以适用于所有项，因此我们可以写出状态转移方程：
* `dp[i]` = `MAX (dp[i-1] + sales[i] , sales[i])`

这个方程可以简单的解释为，以某个数作为结尾，意思就是这个数一定会加上去，那么要看的就是这个数前面的部分要不要加上去。大于零就加，小于零就舍弃。

```java
class Solution {
    public int maxSales(int[] sales) {
        /*
          变量用于在每次循环保存对应索引i的dp[i],以便下一次循环中作为dp[i-1]来使用，
          这样就不用创建一个新数组保存所有dp值，而是只创建一个int变量
          在循环中求dp(i)的同时通过求已保存的maxAns值和当前的dp值的最大值来更新maxAns
         */
        int pre = 0, maxAns = sales[0];
        for (int x : sales) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}
```